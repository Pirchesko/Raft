# PyRaft
Реализация протокола распределенного консенсуса Raft на языке Python

Примечание: это не готовое к использованию программное обеспечение.

# Зачем?
Этот проект был создан во время курса по рафтингу Дэвида Бизли, продолжительностью одну неделю.

# PyRaft
Реализация протокола распределенного консенсуса Raft на языке Python

Примечание: это не готовое к использованию программное обеспечение.

Этот проект был создан во время курса по рафтингу Дэвида Бизли продолжительностью одну неделю. Он содержит базовую реализацию протокола распределенного консенсуса Raft, включая:

- коммуникацию между серверами по сокетам
- репликацию журнала
- выбор лидера
- идемпотентность запросов клиентов
- машина состояний "ключ-значение"
- базовый клиент "ключ-значение"

Некоторые вещи отсутствуют:

- Тесты на уровне сети
- Интеграционные тесты
- Snapshotting
- Изменение конфигурации кластера

## Использование
Серверы можно запускать с помощью утилиты командной строки:
raft start --server 0
raft start --server 1
raft start --server 2
raft start --server 3
raft start --server 4
Эти серверы будут использовать конфигурацию, указанную в src.raft.config. После запуска серверы будут регистрировать свой статус в консоли.

---- Сервер: 1 ----
Здоровый: Истина
Состояние: State.FOLLOWER
Термин: 277
Голосовал за: 4
Индекс фиксации: 71
Тайм-аут выборов: 0/43
------ Журнал ------
 *  LogEntry(term=277, msg=SetValue(request_id=UUID('47213396-24d1-11ea-83a2-f2189812bf51'), key='a', value='b'))
 *  LogEntry(term=277, msg=NoOp(request_id=0))
 *  LogEntry(term=276, msg=NoOp(request_id=0))
 *  LogEntry(term=273, msg=NoOp(request_id=0))
 *  LogEntry(term=270, msg=NoOp(request_id=0))
 *  LogEntry(term=267, msg=NoOp(request_id=0))
 *  LogEntry(term=264, msg=NoOp(request_id=0))
 *  LogEntry(term=256, msg=NoOp(request_id=0))
 *  LogEntry(term=255, msg=NoOp(request_id=0))
 *  LogEntry(term=254, msg=NoOp(request_id=0))

Флаг "здоровый" указывает, все ли потоки управления серверов активны. Неспособность серверов может быть вызвана сбоями на сетевом уровне. Если это произошло, лучший вариант действий заключается в перезапуске нарушающего сервера.

Тайм-аут выборов измеряется в времени между сердечными сокращениями.

Знак * перед записью в журнал указывает, что запись была фиксирована и применена к машине состояний.

## Клиент
Клиент может быть инициализирован следующим образом:

>>> из raft.client импортировать DistDict
>>> из raft.config импортировать SERVERS
>>> клиент = DistDict(SERVERS)

>>> клиент['a'] = 'b'
>>> клиент['a']
b
>>> del client['a']
>>> клиент['a']
None

## Конфигурация
Вся конфигурация задается в файле src.raft.config. Она содержит свойства, такие как тайм-аут для сердечных сокращений и диапазон времени между сердечными сокращениями до вызова тайм-аута выборов. В некоторый момент это следует перенести в переменные окружения.

## Архитектура
Реализация сильно зависит от потоков для многозадачности. Однако "бизнес-логика" Raft работает в одном потоке.

Бизнес-логика Raft реализована в классе src.raft.server.RaftServer, который содержит базовый автомат состояний лидера, кандидата и последователя, а также несколько публичных методов для обработки событий. Среди них:

- handle_message
- handle_election_timeout
- handle_heartbeat

Эти методы вызываются контроллером src.raft.controller.RaftController в его цикле событий. Этот цикл событий извлекает события из очереди событий, таких как сообщения и сердечные сокращения.

RaftServer также реализует исходящую очередь, в которую он может помещать события, такие как сообщения для других серверов или клиентов, а также события для контроллера, такие как сбросы тайм-аута выборов.

Должно быть возможно заменить текущую реализацию контроллера на основе потоков на реализацию с асинхронными IO. Для этого необходимо внедрить исходящую очередь в RaftServer, а не инициализировать ее в методе `__init__`  класса.
RaftController полагается на raft.network.SockBackend для передачи сообщений клиентам и другим серверам. Сообщения получают префикс фиксированного размера, состоящий из 8 битов, указывающий длину следующего сообщения. Сообщения сами представляют собой объекты класса raft.messaging.Message, сериализованные в формате pickle.
